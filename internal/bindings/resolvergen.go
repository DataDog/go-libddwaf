// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

//go:build ignore

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"
)

func main() {
	var typeName string
	flag.StringVar(&typeName, "type", "", "The type for which a resolver is to be generated")
	flag.Parse()

	// Note: $GOFILE is set by the go toolchain when invoking go:generate tools.
	filename := os.Getenv("GOFILE")
	code, err := os.ReadFile(filename)
	if err != nil {
		log.Fatalln(err)
	}

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filename, code, parser.ParseComments)
	if err != nil {
		log.Fatalln(err)
	}

	spec, found := findTypeSpecNamed(file, typeName)
	if !found {
		log.Fatalln("No type named", typeName, "was found in", filename)
	}

	strct, ok := spec.Type.(*ast.StructType)
	if !ok {
		log.Fatalln("Type", typeName, "found in", filename, "is not a struct")
	}

	fields := make(map[string]string, len(strct.Fields.List))
	for idx, field := range strct.Fields.List {
		tag, _ := strconv.Unquote(field.Tag.Value)
		symbol, err := parseSymTag(tag)
		if err != nil {
			log.Fatalln("Error parsing tag for field at index", idx, "of struct", typeName, "in", filename, ":", err)
		}
		if symbol == "" {
			continue
		}

		if len(field.Names) != 1 {
			log.Fatalln("Field at index", idx, "of struct", typeName, "in", filename, "has more than one name")
		}
		fieldName := field.Names[0].Name
		fields[fieldName] = symbol
	}

	if len(fields) == 0 {
		log.Fatalln("No symbols found to resolve for", typeName, "in", filename)
	}

	tmpl := template.Must(template.New("").Parse(goTemplate))
	outFile, err := os.Create(filename[:len(filename)-3] + ".resolveSymbols.go")
	if err != nil {
		log.Fatalln(err)
	}
	defer outFile.Close()

	if err := tmpl.Execute(outFile, &TemplateContext{
		GoBuild:  goBuildDirective(file),
		Package:  file.Name.Name,
		TypeName: typeName,
		Fields:   fields,
	}); err != nil {
		log.Fatalln(err)
	}
}

func findTypeSpecNamed(file *ast.File, typeName string) (*ast.TypeSpec, bool) {
	for _, decl := range file.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, _ := spec.(*ast.TypeSpec)
			if typeSpec.Name.Name == typeName {
				return typeSpec, true
			}
		}
	}
	return nil, false
}

func parseSymTag(tag string) (string, error) {
	tag = strings.TrimSpace(tag)

	for tag != "" {
		name, rest, cut := strings.Cut(tag, ":")
		if !cut {
			return "", fmt.Errorf("Expected ':' in tag value %q", tag)
		}

		if len(rest) == 0 {
			return "", fmt.Errorf(`Expected '"' in tag value %q`, tag)
		}

		i := 1
		for i < len(rest) && rest[i] != '"' {
			if rest[i] == '\\' {
				i++
			}
			i++
		}
		if i >= len(rest) {
			return "", fmt.Errorf("Premature end of tag value in %q", tag)
		}
		qvalue := rest[:i+1]
		if name == "sym" {
			return strconv.Unquote(qvalue)
		}

		tag = strings.TrimSpace(rest[i+1:])
	}

	// No symbol tag found in this tag.
	return "", nil
}

func goBuildDirective(file *ast.File) string {
	for _, comment := range file.Comments {
		for _, item := range comment.List {
			if strings.HasPrefix(item.Text, "//go:build") {
				return item.Text
			}
		}
	}
	return ""
}

const goTemplate = `// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

// Code generated by 'go generate'; DO NOT EDIT.
{{ with .GoBuild }}
{{ . -}}
{{ end }}

package {{ .Package }}

import "github.com/ebitengine/purego"

// {{ .FuncName }} resolves the symbols of [{{ .TypeName }}] from the provided
// [purego.Dlopen] handle.
func {{ .FuncName }}(handle uintptr) (syms {{ .TypeName }}, err error) {
{{- range $field, $symbol := .Fields }}
	if syms.{{ $field }}, err = purego.Dlsym(handle, {{ $symbol | printf "%q" }}); err != nil {
		return syms, err
	}
{{- end }}
	return syms, nil
}
`

type TemplateContext struct {
	GoBuild  string
	Package  string
	TypeName string
	Fields   map[string]string
}

func (t TemplateContext) FuncName() string {
	return "new" + strings.ToUpper(t.TypeName[:1]) + t.TypeName[1:]
}
